import React, { CSSProperties, ReactNode, RefObject, Key, ReactElement, HTMLAttributes, LabelHTMLAttributes, InputHTMLAttributes, ForwardedRef } from "react";
import { CollectionBase, DraggableCollectionProps, DroppableCollectionProps, AriaLabelingProps } from "@react-types/shared";
import { SelectionBehavior, SelectionMode, ItemProps as _ItemProps1, SectionProps as _SectionProps1, CalendarState, RangeCalendarState, ValidationState, DraggableCollectionState, DraggableCollectionStateOptions, DroppableCollectionState, DroppableCollectionStateOptions, ListState, OverlayTriggerState, ComboBoxState, DateFieldState, DateSegmentType, DateSegment as _DateSegment1, OverlayTriggerProps, DatePickerState, DateRangePickerState, MenuTriggerProps as _MenuTriggerProps1, NumberFieldState, SearchFieldState, SelectState, SliderState, DisabledBehavior, SortDirection, TooltipTriggerProps } from "react-stately";
import { AriaLinkOptions, AriaBreadcrumbsProps, AriaButtonProps, CalendarProps as _CalendarProps1, RangeCalendarProps as _RangeCalendarProps1, DateValue, AriaCheckboxGroupProps, AriaCheckboxProps, DropIndicatorProps as _DropIndicatorProps1, DraggableCollectionOptions, DraggableItemProps, DraggableItemResult, DragItem, DragPreview, DropIndicatorAria, DroppableCollectionOptions, DroppableCollectionResult, DroppableItemOptions, DroppableItemResult, DropTarget, DropTargetDelegate, ListDropTargetDelegate, SeparatorProps as _SeparatorProps1, AriaListBoxProps, PlacementAxis, AriaPopoverProps, PositionProps, AriaComboBoxProps, AriaDateFieldProps, AriaTimeFieldProps, TimeValue, AriaModalOverlayProps, AriaDialogProps, AriaDatePickerProps, AriaDateRangePickerProps, AriaGridListProps, AriaMenuProps, AriaMeterProps, AriaNumberFieldProps, AriaProgressBarProps, AriaRadioGroupProps, AriaRadioProps, Orientation, AriaSearchFieldProps, AriaSelectProps, AriaSliderProps, AriaSliderThumbProps, AriaSwitchProps, AriaTabListProps, AriaTabPanelProps, AriaTextFieldProps, AriaToggleButtonProps } from "react-aria";
import { CalendarDate, DateDuration } from "@internationalized/date";
import { TableProps as _TableProps1 } from "@react-types/table";
declare const slotCallbackSymbol: unique symbol;
interface SlottedValue<T> {
    slots?: Record<string | symbol, T>;
    [slotCallbackSymbol]?: (value: T) => void;
}
type ContextValue<T extends SlotProps, E extends Element> = SlottedValue<WithRef<T, E>> | WithRef<T, E> | null | undefined;
type ProviderValue<T> = [React.Context<T>, T];
type ProviderValues<A, B, C, D, E, F, G, H> = [ProviderValue<A>] | [ProviderValue<A>, ProviderValue<B>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>, ProviderValue<E>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>, ProviderValue<E>, ProviderValue<F>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>, ProviderValue<E>, ProviderValue<F>, ProviderValue<G>] | [ProviderValue<A>, ProviderValue<B>, ProviderValue<C>, ProviderValue<D>, ProviderValue<E>, ProviderValue<F>, ProviderValue<G>, ProviderValue<H>];
interface ProviderProps<A, B, C, D, E, F, G, H> {
    values: ProviderValues<A, B, C, D, E, F, G, H>;
    children: React.ReactNode;
}
export function Provider<A, B, C, D, E, F, G, H>({ values, children }: ProviderProps<A, B, C, D, E, F, G, H>): JSX.Element;
interface StyleProps {
    /** The CSS [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) for the element. */
    className?: string;
    /** The inline [style](https://developer.mozilla.org/en-US/docs/Web/API/Element/style) for the element. */
    style?: CSSProperties;
}
interface DOMProps extends StyleProps {
    /** The children of the component. */
    children?: ReactNode;
}
interface StyleRenderProps<T> {
    /** The CSS [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) for the element. A function may be provided to compute the class based on component state. */
    className?: string | ((values: T) => string);
    /** The inline [style](https://developer.mozilla.org/en-US/docs/Web/API/Element/style) for the element. A function may be provided to compute the style based on component state. */
    style?: CSSProperties | ((values: T) => CSSProperties);
}
interface RenderProps<T> extends StyleRenderProps<T> {
    /** The children of the component. A function may be provided to alter the children based on component state. */
    children?: ReactNode | ((values: T) => ReactNode);
}
type WithRef<T, E> = T & {
    ref?: React.ForwardedRef<E>;
};
interface SlotProps {
    /** A slot name for the component. Slots allow the component to receive props from a parent component. */
    slot?: string;
}
export function useContextProps<T, U, E extends Element>(props: T & SlotProps, ref: React.ForwardedRef<E>, context: React.Context<ContextValue<U, E>>): [T, React.RefObject<E>];
interface CollectionProps<T> extends Omit<CollectionBase<T>, 'children'> {
    /** The contents of the collection. */
    children?: ReactNode | ((item: T) => ReactElement);
}
export interface ItemRenderProps {
    /**
     * Whether the item is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the item is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the item is currently selected.
     * @selector [aria-selected=true]
     */
    isSelected: boolean;
    /**
     * Whether the item is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the item is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may
     * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
    /** The type of selection that is allowed in the collection. */
    selectionMode: SelectionMode;
    /** The selection behavior for the collection. */
    selectionBehavior: SelectionBehavior;
    /**
     * Whether the item allows dragging.
     * @note This property is only available in collection components that support drag and drop.
     * @selector [draggable]
     */
    allowsDragging?: boolean;
    /**
     * Whether the item is currently being dragged.
     * @note This property is only available in collection components that support drag and drop.
     * @selector [data-dragging]
     */
    isDragging?: boolean;
    /**
     * Whether the item is currently an active drop target.
     * @note This property is only available in collection components that support drag and drop.
     * @selector [data-drop-target]
     */
    isDropTarget?: boolean;
}
export interface ItemProps<T = object> extends Omit<_ItemProps1<T>, 'children'>, RenderProps<ItemRenderProps> {
    /** The unique id of the item. */
    id?: Key;
    /** The object value that this item represents. When using dynamic collections, this is set automatically. */
    value?: T;
}
export function Item<T extends object>(props: ItemProps<T>): JSX.Element;
export interface SectionProps<T> extends Omit<_SectionProps1<T>, 'children' | 'title'>, DOMProps {
    /** The unique id of the section. */
    id?: Key;
    /** The object value that this section represents. When using dynamic collections, this is set automatically. */
    value?: T;
    /** Static child items or a function to render children. */
    children?: ReactNode | ((item: T) => ReactElement);
}
export function Section<T extends object>(props: SectionProps<T>): JSX.Element;
/** A Collection renders a list of items, automatically managing caching and keys. */
export function Collection<T extends object>(props: CollectionProps<T>): JSX.Element;
export interface HeadingProps extends HTMLAttributes<HTMLElement> {
    level?: number;
}
export const HeadingContext: React.Context<ContextValue<HeadingProps, HTMLHeadingElement>>;
export const Heading: React.ForwardRefExoticComponent<HeadingProps & React.RefAttributes<HTMLHeadingElement>>;
export interface LinkProps extends Omit<AriaLinkOptions, 'elementType'>, RenderProps<LinkRenderProps>, SlotProps {
}
export interface LinkRenderProps {
    /**
     * Whether the link is the current item within a list.
     * @selector [aria-current]
     */
    isCurrent: boolean;
    /**
     * Whether the link is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the link is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the link is focused, either via a mouse or keyboard.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the link is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the link is disabled.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
}
export const LinkContext: React.Context<ContextValue<LinkProps, HTMLAnchorElement>>;
/**
 * A link allows a user to navigate to another page or resource within a web page
 * or application.
 */
export const Link: React.ForwardRefExoticComponent<LinkProps & React.RefAttributes<HTMLAnchorElement>>;
export interface BreadcrumbsProps<T> extends Omit<CollectionProps<T>, 'disabledKeys'>, Omit<AriaBreadcrumbsProps, 'children'>, StyleProps, SlotProps {
    /** Whether the breadcrumbs are disabled. */
    isDisabled?: boolean;
}
export const BreadcrumbsContext: React.Context<ContextValue<BreadcrumbsProps<any>, HTMLElement>>;
/**
 * Breadcrumbs display a heirarchy of links to the current page or resource in an application.
 */
export const Breadcrumbs: <T extends object>(props: BreadcrumbsProps<T> & React.RefAttributes<HTMLElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface ButtonRenderProps {
    /**
     * Whether the button is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the button is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the button is focused, either via a mouse or keyboard.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the button is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the button is disabled.
     * @selector :disabled
     */
    isDisabled: boolean;
}
export interface ButtonProps extends Omit<AriaButtonProps, 'children' | 'href' | 'target' | 'rel' | 'elementType'>, SlotProps, RenderProps<ButtonRenderProps> {
}
interface ButtonContextValue extends ButtonProps {
    isPressed?: boolean;
}
export const ButtonContext: React.Context<ContextValue<ButtonContextValue, HTMLButtonElement>>;
/**
 * A button allows a user to perform an action, with mouse, touch, and keyboard interactions.
 */
export const Button: React.ForwardRefExoticComponent<ButtonProps & React.RefAttributes<HTMLButtonElement>>;
export interface TextProps extends HTMLAttributes<HTMLElement> {
    elementType?: string;
}
export const TextContext: React.Context<ContextValue<TextProps, HTMLElement>>;
export const Text: React.ForwardRefExoticComponent<TextProps & React.RefAttributes<HTMLElement>>;
export interface CalendarProps<T extends DateValue> extends Omit<_CalendarProps1<T>, 'errorMessage'>, RenderProps<CalendarState>, SlotProps {
    /**
     * The amount of days that will be displayed at once. This affects how pagination works.
     * @default {months: 1}
     */
    visibleDuration?: DateDuration;
}
export interface RangeCalendarProps<T extends DateValue> extends Omit<_RangeCalendarProps1<T>, 'errorMessage'>, RenderProps<RangeCalendarState>, SlotProps {
    /**
     * The amount of days that will be displayed at once. This affects how pagination works.
     * @default {months: 1}
     */
    visibleDuration?: DateDuration;
}
export const CalendarContext: React.Context<ContextValue<CalendarProps<any>, HTMLDivElement>>;
export const RangeCalendarContext: React.Context<ContextValue<RangeCalendarProps<any>, HTMLDivElement>>;
/**
 * A calendar displays one or more date grids and allows users to select a single date.
 */
export const Calendar: <T extends DateValue>(props: CalendarProps<T> & React.RefAttributes<HTMLDivElement>) => ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A range calendar displays one or more date grids and allows users to select a contiguous range of dates.
 */
export const RangeCalendar: <T extends DateValue>(props: RangeCalendarProps<T> & React.RefAttributes<HTMLDivElement>) => ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface CalendarCellRenderProps {
    /** The date that the cell represents. */
    date: CalendarDate;
    /** The day number formatted according to the current locale. */
    formattedDate: string;
    /**
     * Whether the cell is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the cell is currently being pressed.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the cell is selected.
     * @selector [data-selected]
     */
    isSelected: boolean;
    /**
     * Whether the cell is the first date in a range selection.
     * @selector [data-selection-start]
     */
    isSelectionStart: boolean;
    /**
     * Whether the cell is the last date in a range selection.
     * @selector [data-selection-end]
     */
    isSelectionEnd: boolean;
    /**
     * Whether the cell is focused.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the cell is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the cell is disabled, according to the calendar's `minValue`, `maxValue`, and `isDisabled` props.
     * Disabled dates are not focusable, and cannot be selected by the user. They are typically
     * displayed with a dimmed appearance.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the cell is outside the visible range of the calendar.
     * For example, dates before the first day of a month in the same week.
     * @selector [data-outside-visible-range]
     */
    isOutsideVisibleRange: boolean;
    /**
     * Whether the cell is outside the current month.
     * @selector [data-outside-month]
     */
    isOutsideMonth: boolean;
    /**
     * Whether the cell is unavailable, according to the calendar's `isDateUnavailable` prop. Unavailable dates remain
     * focusable, but cannot be selected by the user. They should be displayed with a visual affordance to indicate they
     * are unavailable, such as a different color or a strikethrough.
     *
     * Note that because they are focusable, unavailable dates must meet a 4.5:1 color contrast ratio,
     * [as defined by WCAG](https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html).
     *
     * @selector [data-unavailable]
     */
    isUnavailable: boolean;
    /**
     * Whether the cell is part of an invalid selection.
     * @selector [aria-invalid]
     */
    isInvalid: boolean;
}
export interface CalendarGridProps extends StyleProps {
    /**
     * Either a function to render calendar cells for each date in the month,
     * or children containing a `<CalendarGridHeader>`` and `<CalendarGridBody>`
     * when additional customization is needed.
     */
    children?: ReactElement | ReactElement[] | ((date: CalendarDate) => ReactElement);
    /**
     * An offset from the beginning of the visible date range that this
     * CalendarGrid should display. Useful when displaying more than one
     * month at a time.
     */
    offset?: DateDuration;
}
/**
 * A calendar grid displays a single grid of days within a calendar or range calendar which
 * can be keyboard navigated and selected by the user.
 */
export const CalendarGrid: React.ForwardRefExoticComponent<CalendarGridProps & React.RefAttributes<HTMLTableElement>>;
export interface CalendarGridHeaderProps extends StyleProps {
    /** A function to render a `<CalendarHeaderCell>` for a weekday name. */
    children: (day: string) => ReactElement;
}
/**
 * A calendar grid header displays a row of week day names at the top of a month.
 */
export const CalendarGridHeader: React.ForwardRefExoticComponent<CalendarGridHeaderProps & React.RefAttributes<HTMLTableSectionElement>>;
export interface CalendarHeaderCellProps extends DOMProps {
}
/**
 * A calendar header cell displays a week day name at the top of a column within a calendar.
 */
export const CalendarHeaderCell: React.ForwardRefExoticComponent<CalendarHeaderCellProps & React.RefAttributes<HTMLTableCellElement>>;
export interface CalendarGridBodyProps extends StyleProps {
    /** A function to render a `<CalendarCell>` for a given date. */
    children: (date: CalendarDate) => ReactElement;
}
/**
 * A calendar grid body displays a grid of calendar cells within a month.
 */
export const CalendarGridBody: React.ForwardRefExoticComponent<CalendarGridBodyProps & React.RefAttributes<HTMLTableSectionElement>>;
export interface CalendarCellProps extends RenderProps<CalendarCellRenderProps> {
    /** The date to render in the cell. */
    date: CalendarDate;
}
/**
 * A calendar cell displays a date cell within a calendar grid which can be selected by the user.
 */
export const CalendarCell: React.ForwardRefExoticComponent<CalendarCellProps & React.RefAttributes<HTMLDivElement>>;
export interface LabelProps extends LabelHTMLAttributes<HTMLLabelElement> {
    elementType?: string;
}
export const LabelContext: React.Context<ContextValue<LabelProps, HTMLLabelElement>>;
export const Label: React.ForwardRefExoticComponent<LabelProps & React.RefAttributes<HTMLLabelElement>>;
export interface CheckboxGroupProps extends Omit<AriaCheckboxGroupProps, 'children' | 'label' | 'description' | 'errorMessage'>, RenderProps<CheckboxGroupRenderProps>, SlotProps {
}
export interface CheckboxProps extends Omit<AriaCheckboxProps, 'children'>, RenderProps<CheckboxRenderProps>, SlotProps {
}
export interface CheckboxGroupRenderProps {
    /**
     * Whether the checkbox group is disabled.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the checkbox group is read only.
     * @selector [data-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the checkbox group is required.
     * @selector [data-required]
     */
    isRequired: boolean;
    /**
     * The validation state of the checkbox group.
     * @selector [data-validation-state="invalid" | "valid"]
     */
    validationState: ValidationState;
}
export interface CheckboxRenderProps {
    /**
     * Whether the checkbox is selected.
     * @selector [data-selected]
     */
    isSelected: boolean;
    /**
     * Whether the checkbox is selected.
     * @selector [data-indeterminate]
     */
    isIndeterminate: boolean;
    /**
     * Whether the checkbox is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the checkbox is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the checkbox is focused, either via a mouse or keyboard.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the checkbox is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the checkbox is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the checkbox is read only.
     * @selector [data-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the checkbox is valid or invalid.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState?: ValidationState;
    /**
     * Whether the checkbox is required.
     * @selector [data-required]
     */
    isRequired: boolean;
}
export const CheckboxGroupContext: React.Context<ContextValue<CheckboxGroupProps, HTMLDivElement>>;
export const CheckboxContext: React.Context<ContextValue<CheckboxProps, HTMLInputElement>>;
/**
 * A checkbox allows a user to select multiple items from a list of individual items, or
 * to mark one individual item as selected.
 */
export const Checkbox: React.ForwardRefExoticComponent<CheckboxProps & React.RefAttributes<HTMLInputElement>>;
/**
 * A checkbox group allows a user to select multiple items from a list of options.
 */
export const CheckboxGroup: React.ForwardRefExoticComponent<CheckboxGroupProps & React.RefAttributes<HTMLDivElement>>;
export interface InputRenderProps {
    /**
     * Whether the input is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the input is focused, either via a mouse or keyboard.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the input is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the input is disabled.
     * @selector :disabled
     */
    isDisabled: boolean;
}
export interface InputProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'className' | 'style'>, StyleRenderProps<InputRenderProps> {
}
export const InputContext: React.Context<ContextValue<InputProps, HTMLInputElement>>;
/**
 * An input allows a user to input text.
 */
export const Input: React.ForwardRefExoticComponent<InputProps & React.RefAttributes<HTMLInputElement>>;
interface DraggableCollectionStateOpts extends Omit<DraggableCollectionStateOptions, 'getItems'> {
}
interface DragHooks {
    useDraggableCollectionState?: (props: DraggableCollectionStateOpts) => DraggableCollectionState;
    useDraggableCollection?: (props: DraggableCollectionOptions, state: DraggableCollectionState, ref: RefObject<HTMLElement>) => void;
    useDraggableItem?: (props: DraggableItemProps, state: DraggableCollectionState) => DraggableItemResult;
    DragPreview?: typeof DragPreview;
    renderDragPreview?: (items: DragItem[]) => JSX.Element;
}
interface DropHooks {
    useDroppableCollectionState?: (props: DroppableCollectionStateOptions) => DroppableCollectionState;
    useDroppableCollection?: (props: DroppableCollectionOptions, state: DroppableCollectionState, ref: RefObject<HTMLElement>) => DroppableCollectionResult;
    useDroppableItem?: (options: DroppableItemOptions, state: DroppableCollectionState, ref: RefObject<HTMLElement>) => DroppableItemResult;
    useDropIndicator?: (props: _DropIndicatorProps1, state: DroppableCollectionState, ref: RefObject<HTMLElement>) => DropIndicatorAria;
    renderDropIndicator?: (target: DropTarget) => JSX.Element;
    dropTargetDelegate?: DropTargetDelegate;
    ListDropTargetDelegate: typeof ListDropTargetDelegate;
}
export type DragAndDropHooks = DragHooks & DropHooks;
interface DragAndDrop {
    /** Drag and drop hooks for the collection element.  */
    dragAndDropHooks: DragAndDropHooks;
}
export interface DragAndDropOptions extends Omit<DraggableCollectionProps, 'preview' | 'getItems'>, DroppableCollectionProps {
    /**
     * A function that returns the items being dragged. If not specified, we assume that the collection is not draggable.
     * @default () => []
     */
    getItems?: (keys: Set<Key>) => DragItem[];
    /**
     * A function that renders a drag preview, which is shown under the user's cursor while dragging.
     * By default, a copy of the dragged element is rendered.
     */
    renderDragPreview?: (items: DragItem[]) => JSX.Element;
    /**
     * A function that renders a drop indicator element between two items in a collection.
     * This should render a `<DropIndicator>` element. If this function is not provided, a
     * default DropIndicator is provided.
     */
    renderDropIndicator?: (target: DropTarget) => JSX.Element;
    /** A custom delegate object that provides drop targets for pointer coordinates within the collection. */
    dropTargetDelegate?: DropTargetDelegate;
}
/**
 * Provides the hooks required to enable drag and drop behavior for a drag and drop compatible collection component.
 */
export function useDragAndDrop(options: DragAndDropOptions): DragAndDrop;
export const DropIndicatorContext: React.Context<DropIndicatorContextValue>;
interface DropIndicatorRenderProps {
    /**
     * Whether the drop indicator is currently the active drop target.
     * @selector [data-drop-target]
     */
    isDropTarget: boolean;
}
interface DropIndicatorProps extends _DropIndicatorProps1, RenderProps<DropIndicatorRenderProps> {
}
interface DropIndicatorContextValue {
    render: (props: DropIndicatorProps, ref: ForwardedRef<HTMLElement>) => ReactNode;
}
/**
 * A DropIndicator is rendered between items in a collection to indicate where dropped data will be inserted.
 */
export const DropIndicator: React.ForwardRefExoticComponent<DropIndicatorProps & React.RefAttributes<HTMLElement>>;
export const Header: React.ForwardRefExoticComponent<React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement>>;
export interface SeparatorProps extends _SeparatorProps1, StyleProps, SlotProps {
}
export const SeparatorContext: React.Context<ContextValue<SeparatorProps, Element>>;
export const Separator: React.ForwardRefExoticComponent<SeparatorProps & React.RefAttributes<Element>>;
export interface ListBoxRenderProps {
    /**
     * Whether the listbox has no items and should display its empty state.
     * @selector [data-empty]
     */
    isEmpty: boolean;
    /**
     * Whether the listbox is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the listbox is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the listbox is currently the active drop target.
     * @selector [data-drop-target]
     */
    isDropTarget: boolean;
}
export interface ListBoxProps<T> extends Omit<AriaListBoxProps<T>, 'children'>, CollectionProps<T>, StyleRenderProps<ListBoxRenderProps>, SlotProps {
    /** How multiple selection should behave in the collection. */
    selectionBehavior?: SelectionBehavior;
    /** The drag and drop hooks returned by `useDragAndDrop` used to enable drag and drop behavior for the ListBox. */
    dragAndDropHooks?: DragAndDropHooks;
    /** Provides content to display when there are no items in the list. */
    renderEmptyState?: () => ReactNode;
}
interface ListBoxContextValue<T> extends ListBoxProps<T> {
    state?: ListState<T>;
}
export const ListBoxContext: React.Context<ContextValue<ListBoxContextValue<any>, HTMLDivElement>>;
/**
 * A listbox displays a list of options and allows a user to select one or more of them.
 */
export const ListBox: <T>(props: ListBoxProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface OverlayArrowProps extends Omit<HTMLAttributes<HTMLDivElement>, 'className' | 'style' | 'children'>, RenderProps<OverlayArrowRenderProps> {
}
export interface OverlayArrowRenderProps {
    /**
     * The placement of the overlay relative to the trigger.
     * @selector [data-placement="left | right | top | bottom"]
     */
    placement: PlacementAxis;
}
/**
 * An OverlayArrow renders a custom arrow element relative to an overlay element
 * such as a popover or tooltip such that it aligns with a trigger element.
 */
export const OverlayArrow: React.ForwardRefExoticComponent<OverlayArrowProps & React.RefAttributes<HTMLDivElement>>;
export interface PopoverProps extends Omit<PositionProps, 'isOpen'>, Omit<AriaPopoverProps, 'popoverRef' | 'triggerRef'>, RenderProps<PopoverRenderProps>, SlotProps {
    /**
     * The ref for the element which the popover positions itself with respect to.
     *
     * When used within a trigger component such as DialogTrigger, MenuTrigger, Select, etc.,
     * this is set automatically. It is only required when used standalone.
     */
    triggerRef?: RefObject<Element>;
}
export interface PopoverRenderProps {
    /**
     * The placement of the tooltip relative to the trigger.
     * @selector [data-placement="left | right | top | bottom"]
     */
    placement: PlacementAxis;
    /**
     * Whether the popover is currently entering. Use this to apply animations.
     * @selector [data-entering]
     */
    isEntering: boolean;
    /**
     * Whether the popover is currently exiting. Use this to apply animations.
     * @selector [data-exiting]
     */
    isExiting: boolean;
}
interface PopoverContextValue extends PopoverProps {
    state: OverlayTriggerState;
    preserveChildren?: boolean;
    triggerRef: RefObject<Element>;
}
export const PopoverContext: React.Context<ContextValue<PopoverContextValue, HTMLElement>>;
/**
 * A popover is an overlay element positioned relative to a trigger.
 */
export const Popover: React.ForwardRefExoticComponent<PopoverProps & React.RefAttributes<HTMLElement>>;
export interface ComboBoxProps<T extends object> extends Omit<AriaComboBoxProps<T>, 'children' | 'placeholder' | 'name' | 'label' | 'description' | 'errorMessage'>, RenderProps<ComboBoxState<T>>, SlotProps {
    /** The filter function used to determine if a option should be included in the combo box list. */
    defaultFilter?: (textValue: string, inputValue: string) => boolean;
}
export const ComboBoxContext: React.Context<ContextValue<ComboBoxProps<any>, HTMLDivElement>>;
/**
 * A combo box combines a text input with a listbox, allowing users to filter a list of options to items matching a query.
 */
export const ComboBox: <T extends object>(props: ComboBoxProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface DateFieldProps<T extends DateValue> extends Omit<AriaDateFieldProps<T>, 'label' | 'description' | 'errorMessage'>, RenderProps<DateFieldState>, SlotProps {
}
export interface TimeFieldProps<T extends TimeValue> extends Omit<AriaTimeFieldProps<T>, 'label' | 'description' | 'errorMessage'>, RenderProps<DateFieldState>, SlotProps {
}
export const DateFieldContext: React.Context<ContextValue<DateFieldProps<any>, HTMLDivElement>>;
export const TimeFieldContext: React.Context<ContextValue<TimeFieldProps<any>, HTMLDivElement>>;
/**
 * A date field allows users to enter and edit date and time values using a keyboard.
 * Each part of a date value is displayed in an individually editable segment.
 */
export const DateField: <T extends DateValue>(props: DateFieldProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A time field allows users to enter and edit time values using a keyboard.
 * Each part of a time value is displayed in an individually editable segment.
 */
export const TimeField: <T extends TimeValue>(props: TimeFieldProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface DateInputRenderProps {
    /**
     * Whether the date input is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether an element within the date input is focused, either via a mouse or keyboard.
     * @selector :focus-within
     */
    isFocusWithin: boolean;
    /**
     * Whether an element within the date input is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the date input is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
}
export interface DateInputProps extends SlotProps, StyleRenderProps<DateInputRenderProps> {
    children: (segment: _DateSegment1) => ReactElement;
}
/**
 * A date input groups the editable date segments within a date field.
 */
export const DateInput: React.ForwardRefExoticComponent<DateInputProps & React.RefAttributes<HTMLDivElement>>;
export interface DateSegmentRenderProps extends Omit<_DateSegment1, 'isEditable'> {
    /**
     * Whether the value is a placeholder.
     * @selector [data-placeholder]
     */
    isPlaceholder: boolean;
    /**
     * Whether the segment is read only.
     * @selector [aria-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the date field is in an invalid state.
     * @selector [aria-invalid]
     */
    isInvalid: boolean;
    /**
     * The type of segment. Values include `literal`, `year`, `month`, `day`, etc.
     * @selector [data-type="..."]
     */
    type: DateSegmentType;
}
export interface DateSegmentProps extends RenderProps<DateSegmentRenderProps> {
    segment: _DateSegment1;
}
/**
 * A date segment displays an individual unit of a date and time, and allows users to edit
 * the value by typing or using the arrow keys to increment and decrement.
 */
export const DateSegment: React.ForwardRefExoticComponent<DateSegmentProps & React.RefAttributes<HTMLDivElement>>;
export interface ModalOverlayProps extends AriaModalOverlayProps, OverlayTriggerProps, RenderProps<ModalRenderProps> {
}
interface ModalContextValue {
    state?: OverlayTriggerState;
}
export const ModalContext: React.Context<ModalContextValue>;
export interface ModalRenderProps {
    /**
     * Whether the modal is currently entering. Use this to apply animations.
     * @selector [data-entering]
     */
    isEntering: boolean;
    /**
     * Whether the modal is currently exiting. Use this to apply animations.
     * @selector [data-exiting]
     */
    isExiting: boolean;
}
/**
 * A modal is an overlay element which blocks interaction with elements outside it.
 */
export const Modal: React.ForwardRefExoticComponent<ModalOverlayProps & React.RefAttributes<HTMLDivElement>>;
/**
 * A ModalOverlay is a wrapper for a Modal which allows customizing the backdrop element.
 */
export const ModalOverlay: React.ForwardRefExoticComponent<ModalOverlayProps & React.RefAttributes<HTMLDivElement>>;
export interface DialogTriggerProps extends OverlayTriggerProps {
    children: ReactNode;
}
interface DialogRenderProps {
    close: () => void;
}
export interface DialogProps extends AriaDialogProps, DOMProps, SlotProps {
    children?: ReactNode | ((opts: DialogRenderProps) => ReactNode);
    onClose?: () => void;
}
export const DialogContext: React.Context<ContextValue<DialogProps, HTMLElement>>;
/**
 * A DialogTrigger opens a dialog when a trigger element is pressed.
 */
export function DialogTrigger(props: DialogTriggerProps): JSX.Element;
/**
 * A dialog is an overlay shown above other content in an application.
 */
export const Dialog: React.ForwardRefExoticComponent<DialogProps & React.RefAttributes<HTMLElement>>;
export interface GroupRenderProps {
    /**
     * Whether the group is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether an element within the group is focused, either via a mouse or keyboard.
     * @selector :focus-within
     */
    isFocusWithin: boolean;
    /**
     * Whether an element within the group is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
}
export interface GroupProps extends Omit<HTMLAttributes<HTMLElement>, 'className' | 'style'>, StyleRenderProps<GroupRenderProps> {
}
export const GroupContext: React.Context<ContextValue<GroupProps, HTMLDivElement>>;
/**
 * An group represents a set of related UI controls.
 */
export const Group: React.ForwardRefExoticComponent<GroupProps & React.RefAttributes<HTMLDivElement>>;
export interface DatePickerProps<T extends DateValue> extends Omit<AriaDatePickerProps<T>, 'label' | 'description' | 'errorMessage'>, RenderProps<DatePickerState>, SlotProps {
}
export interface DateRangePickerProps<T extends DateValue> extends Omit<AriaDateRangePickerProps<T>, 'label' | 'description' | 'errorMessage'>, RenderProps<DateRangePickerState>, SlotProps {
}
export const DatePickerContext: React.Context<ContextValue<DatePickerProps<any>, HTMLDivElement>>;
export const DateRangePickerContext: React.Context<ContextValue<DateRangePickerProps<any>, HTMLDivElement>>;
/**
 * A date picker combines a DateField and a Calendar popover to allow users to enter or select a date and time value.
 */
export const DatePicker: <T extends DateValue>(props: DatePickerProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A date range picker combines two DateFields and a RangeCalendar popover to allow
 * users to enter or select a date and time range.
 */
export const DateRangePicker: <T extends DateValue>(props: DateRangePickerProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface GridListRenderProps {
    /**
     * Whether the list has no items and should display its empty state.
     * @selector [data-empty]
     */
    isEmpty: boolean;
    /**
     * Whether the grid list is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the grid list is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the grid list is currently the active drop target.
     * @selector [data-drop-target]
     */
    isDropTarget: boolean;
}
export interface GridListProps<T> extends Omit<AriaGridListProps<T>, 'children'>, CollectionProps<T>, StyleRenderProps<GridListRenderProps>, SlotProps {
    /** How multiple selection should behave in the collection. */
    selectionBehavior?: SelectionBehavior;
    /** The drag and drop hooks returned by `useDragAndDrop` used to enable drag and drop behavior for the GridList. */
    dragAndDropHooks?: DragAndDropHooks;
    /** Provides content to display when there are no items in the list. */
    renderEmptyState?: () => ReactNode;
}
export const GridListContext: React.Context<ContextValue<GridListProps<any>, HTMLDivElement>>;
/**
 * A grid list displays a list of interactive items, with support for keyboard navigation,
 * single or multiple selection, and row actions.
 */
export const GridList: <T extends object>(props: GridListProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export const KeyboardContext: React.Context<ContextValue<React.HTMLAttributes<HTMLElement>, HTMLElement>>;
export const Keyboard: React.ForwardRefExoticComponent<React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement>>;
export const MenuContext: React.Context<ContextValue<MenuProps<any>, HTMLDivElement>>;
export interface MenuTriggerProps extends _MenuTriggerProps1 {
    children?: ReactNode;
}
export function MenuTrigger(props: MenuTriggerProps): JSX.Element;
export interface MenuProps<T> extends Omit<AriaMenuProps<T>, 'children'>, CollectionProps<T>, StyleProps, SlotProps {
}
/**
 * A menu displays a list of actions or options that a user can choose.
 */
export const Menu: <T extends object>(props: MenuProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface MenuItemRenderProps extends ItemRenderProps {
    /**
     * Whether the item is currently selected.
     * @selector [aria-checked=true]
     */
    isSelected: boolean;
}
export interface MeterProps extends Omit<AriaMeterProps, 'label'>, RenderProps<MeterRenderProps>, SlotProps {
}
export interface MeterRenderProps {
    /**
     * The value as a percentage between the minimum and maximum.
     */
    percentage: number;
    /**
     * A formatted version of the value.
     * @selector [aria-valuetext]
     */
    valueText?: string;
}
export const MeterContext: React.Context<ContextValue<MeterProps, HTMLDivElement>>;
/**
 * A meter represents a quantity within a known range, or a fractional value.
 */
export const Meter: React.ForwardRefExoticComponent<MeterProps & React.RefAttributes<HTMLDivElement>>;
export interface NumberFieldProps extends Omit<AriaNumberFieldProps, 'label' | 'placeholder' | 'description' | 'errorMessage'>, RenderProps<NumberFieldState>, SlotProps {
}
export const NumberFieldContext: React.Context<ContextValue<NumberFieldProps, HTMLDivElement>>;
/**
 * A number field allows a user to enter a number, and increment or decrement the value using stepper buttons.
 */
export const NumberField: React.ForwardRefExoticComponent<NumberFieldProps & React.RefAttributes<HTMLDivElement>>;
export interface ProgressBarProps extends Omit<AriaProgressBarProps, 'label'>, RenderProps<ProgressBarRenderProps>, SlotProps {
}
export interface ProgressBarRenderProps {
    /**
     * The value as a percentage between the minimum and maximum.
     */
    percentage?: number;
    /**
     * A formatted version of the value.
     * @selector [aria-valuetext]
     */
    valueText?: string;
    /**
     * Whether the progress bar is indeterminate.
     * @selector :not([aria-valuenow])
     */
    isIndeterminate: boolean;
}
export const ProgressBarContext: React.Context<ContextValue<ProgressBarProps, HTMLDivElement>>;
/**
 * Progress bars show either determinate or indeterminate progress of an operation
 * over time.
 */
export const ProgressBar: React.ForwardRefExoticComponent<ProgressBarProps & React.RefAttributes<HTMLDivElement>>;
export interface RadioGroupProps extends Omit<AriaRadioGroupProps, 'children' | 'label' | 'description' | 'errorMessage'>, RenderProps<RadioGroupRenderProps>, SlotProps {
}
export interface RadioProps extends Omit<AriaRadioProps, 'children'>, RenderProps<RadioRenderProps> {
}
export interface RadioGroupRenderProps {
    /**
     * The orientation of the radio group.
     * @selector [aria-orientation="horizontal | vertical"]
     */
    orientation: Orientation;
    /**
     * Whether the radio group is disabled.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the radio group is read only.
     * @selector [aria-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the radio group is required.
     * @selector [aria-required]
     */
    isRequired: boolean;
    /**
     * The validation state of the radio group.
     * @selector [aria-invalid]
     */
    validationState: ValidationState | null;
}
export interface RadioRenderProps {
    /**
     * Whether the radio is selected.
     * @selector [data-selected]
     */
    isSelected: boolean;
    /**
     * Whether the radio is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the radio is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the radio is focused, either via a mouse or keyboard.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the radio is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the radio is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the radio is read only.
     * @selector [data-readonly]
     */
    isReadOnly: boolean;
    /**
     * Whether the radio is valid or invalid.
     * @selector [data-validation-state="valid | invalid"]
     */
    validationState: ValidationState | null;
    /**
     * Whether the checkbox is required.
     * @selector [data-required]
     */
    isRequired: boolean;
}
export const RadioGroupContext: React.Context<ContextValue<RadioGroupProps, HTMLDivElement>>;
/**
 * A radio group allows a user to select a single item from a list of mutually exclusive options.
 */
export const RadioGroup: React.ForwardRefExoticComponent<RadioGroupProps & React.RefAttributes<HTMLDivElement>>;
/**
 * A radio represents an individual option within a radio group.
 */
export const Radio: React.ForwardRefExoticComponent<RadioProps & React.RefAttributes<HTMLInputElement>>;
export interface SearchFieldProps extends Omit<AriaSearchFieldProps, 'label' | 'placeholder' | 'description' | 'errorMessage'>, RenderProps<SearchFieldState>, SlotProps {
}
export interface SearchFieldRenderProps {
    /**
     * Whether the search field is empty.
     * @selector [data-empty]
     */
    isEmpty: boolean;
}
export const SearchFieldContext: React.Context<ContextValue<SearchFieldProps, HTMLDivElement>>;
/**
 * A search field allows a user to enter and clear a search query.
 */
export const SearchField: React.ForwardRefExoticComponent<SearchFieldProps & React.RefAttributes<HTMLDivElement>>;
export interface SelectProps<T extends object> extends Omit<AriaSelectProps<T>, 'children' | 'label' | 'description' | 'errorMessage'>, RenderProps<SelectState<T>>, SlotProps {
}
export const SelectContext: React.Context<ContextValue<SelectProps<any>, HTMLDivElement>>;
/**
 * A select displays a collapsible list of options and allows a user to select one of them.
 */
export const Select: <T extends object>(props: SelectProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SelectValueRenderProps<T> {
    /**
     * Whether the value is a placeholder.
     * @selector [data-placeholder]
     */
    isPlaceholder: boolean;
    /** The object value of the currently selected item. */
    selectedItem: T | null;
    /** The textValue of the currently selected item. */
    selectedText: string | null;
}
export interface SelectValueProps<T extends object> extends Omit<HTMLAttributes<HTMLElement>, keyof RenderProps<unknown>>, RenderProps<SelectValueRenderProps<T>> {
}
/**
 * SelectValue renders the current value of a Select, or a placeholder if no value is selected.
 * It is usually placed within the button element.
 */
export const SelectValue: <T extends object>(props: SelectValueProps<T> & React.RefAttributes<HTMLSpanElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SliderProps<T = number | number[]> extends AriaSliderProps<T>, RenderProps<SliderState>, SlotProps {
    /**
     * The display format of the value label.
     */
    formatOptions?: Intl.NumberFormatOptions;
}
export const SliderContext: React.Context<ContextValue<SliderProps<number | number[]>, HTMLDivElement>>;
export interface SliderRenderProps {
    /**
     * The orientation of the slider.
     * @selector [data-orientation="horizontal | vertical"]
     */
    orientation: Orientation;
    /**
     * Whether the slider is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
}
/**
 * A slider allows a user to select one or more values within a range.
 */
export const Slider: <T extends number | number[]>(props: SliderProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
export interface SliderOutputProps extends RenderProps<SliderState> {
}
/**
 * A slider output displays the current value of a slider as text.
 */
export const SliderOutput: React.ForwardRefExoticComponent<SliderOutputProps & React.RefAttributes<HTMLOutputElement>>;
export interface SliderTrackProps extends RenderProps<SliderState> {
}
/**
 * A slider track is a container for one or more slider thumbs.
 */
export const SliderTrack: React.ForwardRefExoticComponent<SliderTrackProps & React.RefAttributes<HTMLDivElement>>;
export interface SliderThumbRenderProps {
    /** The slider state object. */
    state: SliderState;
    /**
     * Whether this thumb is currently being dragged.
     * @selector [data-dragging]
     */
    isDragging: boolean;
    /**
     * Whether the thumb is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the thumb is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the thumb is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the thumb is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
}
export interface SliderThumbProps extends AriaSliderThumbProps, RenderProps<SliderThumbRenderProps> {
}
/**
 * A slider thumb represents an individual value that the user can adjust within a slider track.
 */
export const SliderThumb: React.ForwardRefExoticComponent<SliderThumbProps & React.RefAttributes<HTMLDivElement>>;
export interface SwitchProps extends Omit<AriaSwitchProps, 'children'>, RenderProps<SwitchRenderProps>, SlotProps {
}
export interface SwitchRenderProps {
    /**
     * Whether the switch is selected.
     * @selector [data-selected]
     */
    isSelected: boolean;
    /**
     * Whether the switch is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the switch is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the switch is focused, either via a mouse or keyboard.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the switch is keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the switch is disabled.
     * @selector [data-disabled]
     */
    isDisabled: boolean;
    /**
     * Whether the switch is read only.
     * @selector [data-readonly]
     */
    isReadOnly: boolean;
}
export const SwitchContext: React.Context<ContextValue<SwitchProps, HTMLInputElement>>;
/**
 * A switch allows a user to turn a setting on or off.
 */
export const Switch: React.ForwardRefExoticComponent<SwitchProps & React.RefAttributes<HTMLInputElement>>;
export const TableContext: React.Context<ContextValue<TableProps, HTMLTableElement>>;
export interface TableRenderProps {
    /**
     * Whether the table is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the table is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the table is currently the active drop target.
     * @selector [data-drop-target]
     */
    isDropTarget: boolean;
}
export interface TableProps extends Omit<_TableProps1<any>, 'children'>, StyleRenderProps<TableRenderProps>, SlotProps, AriaLabelingProps {
    /** The elements that make up the table. Includes the TableHeader, TableBody, Columns, and Rows. */
    children?: ReactNode;
    /**
     * How multiple selection should behave in the collection.
     * @default "toggle"
     */
    selectionBehavior?: SelectionBehavior;
    /**
     * Whether `disabledKeys` applies to all interactions, or only selection.
     * @default "selection"
     */
    disabledBehavior?: DisabledBehavior;
    /** Handler that is called when a user performs an action on the row. */
    onRowAction?: (key: Key) => void;
    /** Handler that is called when a user performs an action on the cell. */
    onCellAction?: (key: Key) => void;
    /** The drag and drop hooks returned by `useDragAndDrop` used to enable drag and drop behavior for the Table. */
    dragAndDropHooks?: DragAndDropHooks;
}
/**
 * A table displays data in rows and columns and enables a user to navigate its contents via directional navigation keys,
 * and optionally supports row selection and sorting.
 */
export const Table: React.ForwardRefExoticComponent<TableProps & React.RefAttributes<HTMLTableElement>>;
interface TableOptionsContextValue {
    /** The type of selection that is allowed in the table. */
    selectionMode: SelectionMode;
    /** The selection behavior for the table. If selectionMode is `"none"`, this will be `null`. */
    selectionBehavior: SelectionBehavior | null;
    /** Whether the table allows empty selection. */
    disallowEmptySelection: boolean;
    /** Whether the table allows rows to be dragged. */
    allowsDragging: boolean;
}
/**
 * Returns options from the parent `<Table>` component.
 */
export function useTableOptions(): TableOptionsContextValue;
export interface TableHeaderProps<T> {
    /** A list of table columns. */
    columns?: T[];
    /** A list of `Column(s)` or a function. If the latter, a list of columns must be provided using the `columns` prop. */
    children?: ReactNode | ((item: T) => ReactElement);
}
/**
 * A header within a `<Table>`, containing the table columns.
 */
export function TableHeader<T extends object>(props: TableHeaderProps<T>): JSX.Element;
export interface ColumnRenderProps {
    /**
     * Whether the item is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the item is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the column allows sorting.
     * @selector [aria-sort]
     */
    allowsSorting: boolean;
    /**
     * The current sort direction.
     * @selector [aria-sort="ascending | descending"]
     */
    sortDirection?: SortDirection;
}
export interface ColumnProps<T = object> extends RenderProps<ColumnRenderProps> {
    id?: Key;
    /** Rendered contents of the column if `children` contains child columns. */
    title?: ReactNode;
    /** A list of child columns used when dynamically rendering nested child columns. */
    childColumns?: T[];
    /** Whether the column allows sorting. */
    allowsSorting?: boolean;
    /** Whether a column is a [row header](https://www.w3.org/TR/wai-aria-1.1/#rowheader) and should be announced by assistive technology during row navigation. */
    isRowHeader?: boolean;
    /** A string representation of the column's contents, used for accessibility announcements. */
    textValue?: string;
}
/**
 * A column within a `<Table>`.
 */
export function Column<T extends object>(props: ColumnProps<T>): JSX.Element;
interface TableBodyRenderProps {
    /**
     * Whether the table body has no rows and should display its empty state.
     * @selector [data-empty]
     */
    isEmpty: boolean;
}
export interface TableBodyProps<T> extends CollectionProps<T>, StyleRenderProps<TableBodyRenderProps> {
    /** Provides content to display when there are no rows in the table. */
    renderEmptyState?: () => ReactNode;
}
/**
 * The body of a `<Table>`, containing the table rows.
 */
export function TableBody<T extends object>(props: TableBodyProps<T>): JSX.Element;
export interface RowRenderProps extends ItemRenderProps {
}
export interface RowProps<T> extends RenderProps<RowRenderProps> {
    id?: Key;
    /** A list of columns used when dynamically rendering cells. */
    columns?: Iterable<T>;
    /** The cells within the row. Supports static items or a function for dynamic rendering. */
    children?: ReactNode | ((item: T) => ReactElement);
    /** A string representation of the row's contents, used for features like typeahead. */
    textValue?: string;
}
/**
 * A row within a `<Table>`.
 */
export function Row<T extends object>(props: RowProps<T>): JSX.Element;
export interface CellRenderProps {
    /**
     * Whether the cell is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the cell is currently focused.
     * @selector [data-focused]
     */
    isFocused: boolean;
    /**
     * Whether the cell is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
}
export interface CellProps extends RenderProps<CellRenderProps> {
    id?: Key;
    /** The contents of the cell. */
    children: ReactNode;
    /** A string representation of the cell's contents, used for features like typeahead. */
    textValue?: string;
}
/**
 * A cell within a table row.
 */
export function Cell(props: CellProps): JSX.Element;
export interface TabsProps extends RenderProps<TabsRenderProps>, SlotProps {
    /**
     * The orientation of the tabs.
     * @default 'horizontal'
     */
    orientation?: Orientation;
}
export interface TabsRenderProps {
    /**
     * The orientation of the tabs.
     * @selector [data-orientation="horizontal | vertical"]
     */
    orientation: Orientation;
}
export interface TabListProps<T> extends Omit<AriaTabListProps<T>, 'children' | 'orientation'>, StyleRenderProps<TabListRenderProps>, AriaLabelingProps, CollectionProps<T> {
}
export interface TabListRenderProps {
    /**
     * The orientation of the tab list.
     * @selector [aria-orientation="horizontal | vertical"]
     */
    orientation: Orientation;
}
export interface TabProps extends RenderProps<TabRenderProps>, AriaLabelingProps {
    id?: Key;
}
export interface TabRenderProps {
    /**
     * Whether the tab is currently hovered with a mouse.
     * @selector [data-hovered]
     */
    isHovered: boolean;
    /**
     * Whether the tab is currently in a pressed state.
     * @selector [data-pressed]
     */
    isPressed: boolean;
    /**
     * Whether the tab is currently selected.
     * @selector [aria-selected=true]
     */
    isSelected: boolean;
    /**
     * Whether the tab is currently focused.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the tab is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
    /**
     * Whether the tab is disabled.
     * @selector [aria-disabled]
     */
    isDisabled: boolean;
}
export interface TabPanelProps extends AriaTabPanelProps, RenderProps<TabPanelRenderProps> {
}
export interface TabPanelRenderProps {
    /**
     * Whether the tab panel is currently focused.
     * @selector :focus
     */
    isFocused: boolean;
    /**
     * Whether the tab panel is currently keyboard focused.
     * @selector [data-focus-visible]
     */
    isFocusVisible: boolean;
}
export const TabsContext: React.Context<ContextValue<TabsProps, HTMLDivElement>>;
/**
 * Tabs organize content into multiple sections and allow users to navigate between them.
 */
export const Tabs: React.ForwardRefExoticComponent<TabsProps & React.RefAttributes<HTMLDivElement>>;
/**
 * A TabList is used within Tabs to group tabs that a user can switch between.
 * The ids of the items within the <TabList> must match up with a corresponding item inside the <TabPanels>.
 */
export const TabList: <T extends object>(props: TabListProps<T> & React.RefAttributes<HTMLDivElement>) => React.ReactElement<any, string | React.JSXElementConstructor<any>>;
/**
 * A Tab provides a title for an individual item within a TabList.
 */
export function Tab(props: TabProps): JSX.Element;
export interface TabPanelsProps<T> extends Omit<CollectionProps<T>, 'disabledKeys'> {
}
/**
 * TabPanels is used within Tabs as a container for the content of each tab.
 * The ids of the items within the <TabPanels> must match up with a corresponding item inside the <TabList>.
 */
export function TabPanels<T extends object>(props: TabPanelsProps<T>): JSX.Element;
/**
 * A TabPanel provides the content for a tab.
 */
export function TabPanel(props: TabPanelProps): JSX.Element;
export interface TextFieldProps extends Omit<AriaTextFieldProps, 'label' | 'placeholder' | 'description' | 'errorMessage'>, DOMProps, SlotProps {
}
export const TextFieldContext: React.Context<ContextValue<TextFieldProps, HTMLDivElement>>;
/**
 * A text field allows a user to enter a plain text value with a keyboard.
 */
export const TextField: React.ForwardRefExoticComponent<TextFieldProps & React.RefAttributes<HTMLDivElement>>;
export interface ToggleButtonRenderProps extends ButtonRenderProps {
    /**
     * Whether the button is currently selected.
     * @selector [aria-pressed=true]
     */
    isSelected: boolean;
}
export interface ToggleButtonProps extends Omit<AriaToggleButtonProps, 'children' | 'elementType'>, SlotProps, RenderProps<ToggleButtonRenderProps> {
}
export const ToggleButtonContext: React.Context<ContextValue<ToggleButtonProps, HTMLButtonElement>>;
/**
 * A toggle button allows a user to toggle a selection on or off, for example switching between two states or modes.
 */
export const ToggleButton: React.ForwardRefExoticComponent<ToggleButtonProps & React.RefAttributes<HTMLButtonElement>>;
export interface TooltipTriggerComponentProps extends TooltipTriggerProps {
    children: ReactNode;
}
export interface TooltipProps extends PositionProps, AriaLabelingProps, RenderProps<TooltipRenderProps> {
}
export interface TooltipRenderProps {
    /**
     * The placement of the tooltip relative to the trigger.
     * @selector [data-placement="left | right | top | bottom"]
     */
    placement: PlacementAxis;
    /**
     * Whether the tooltip is currently entering. Use this to apply animations.
     * @selector [data-entering]
     */
    isEntering: boolean;
    /**
     * Whether the tooltip is currently exiting. Use this to apply animations.
     * @selector [data-exiting]
     */
    isExiting: boolean;
}
/**
 * TooltipTrigger wraps around a trigger element and a Tooltip. It handles opening and closing
 * the Tooltip when the user hovers over or focuses the trigger, and positioning the Tooltip
 * relative to the trigger.
 */
export function TooltipTrigger(props: TooltipTriggerComponentProps): JSX.Element;
/**
 * A tooltip displays a description of an element on hover or focus.
 */
export const Tooltip: React.ForwardRefExoticComponent<TooltipProps & React.RefAttributes<HTMLDivElement>>;
export { DIRECTORY_DRAG_TYPE, isDirectoryDropItem, isFileDropItem, isTextDropItem, SSRProvider } from 'react-aria';
export type { DateValue, DateRange, TimeValue } from 'react-aria';
export type { DirectoryDropItem, DraggableCollectionEndEvent, DraggableCollectionMoveEvent, DraggableCollectionStartEvent, DragPreviewRenderer, DragTypes, DropItem, DropOperation, DroppableCollectionDropEvent, DroppableCollectionEnterEvent, DroppableCollectionExitEvent, DroppableCollectionInsertDropEvent, DroppableCollectionMoveEvent, DroppableCollectionOnItemDropEvent, DroppableCollectionReorderEvent, DroppableCollectionRootDropEvent, DropPosition, DropTarget, FileDropItem, ItemDropTarget, RootDropTarget, TextDropItem } from 'react-aria';
export type { Selection } from 'react-stately';

//# sourceMappingURL=types.d.ts.map
